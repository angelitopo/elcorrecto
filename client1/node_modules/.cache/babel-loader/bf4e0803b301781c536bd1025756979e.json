{"ast":null,"code":"import { useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\nimport { getWillChangeName } from '../../value/use-will-change/get-will-change-name.mjs';\nfunction makeState({\n  applyWillChange = false,\n  scrapeMotionValuesFromProps,\n  createRenderState,\n  onMount\n}, props, context, presenceContext, isStatic) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = instance => onMount(props, instance, state);\n  }\n  return state;\n}\nconst makeUseVisualState = config => (props, isStatic) => {\n  const context = useContext(MotionContext);\n  const presenceContext = useContext(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext, isStatic);\n  return isStatic ? make() : useConstant(make);\n};\nfunction forEachDefinition(props, definition, callback) {\n  const list = Array.isArray(definition) ? definition : [definition];\n  for (let i = 0; i < list.length; i++) {\n    const resolved = resolveVariantFromProps(props, list[i]);\n    if (resolved) {\n      const {\n        transitionEnd,\n        transition,\n        ...target\n      } = resolved;\n      callback(target, transitionEnd);\n    }\n  }\n}\nfunction makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {\n  var _a;\n  const values = {};\n  let applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;\n  const motionValues = scrapeMotionValues(props, {});\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let {\n    initial,\n    animate\n  } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === undefined) initial = context.initial;\n    if (animate === undefined) animate = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    forEachDefinition(props, variantToSet, (target, transitionEnd) => {\n      for (const key in target) {\n        let valueTarget = target[key];\n        if (Array.isArray(valueTarget)) {\n          /**\n           * Take final keyframe if the initial animation is blocked because\n           * we want to initialise at the end of that blocked animation.\n           */\n          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n          valueTarget = valueTarget[index];\n        }\n        if (valueTarget !== null) {\n          values[key] = valueTarget;\n        }\n      }\n      for (const key in transitionEnd) {\n        values[key] = transitionEnd[key];\n      }\n    });\n  }\n  // Add animating values to will-change\n  if (applyWillChange) {\n    if (animate && initial !== false && !isAnimationControls(animate)) {\n      forEachDefinition(props, animate, target => {\n        for (const key in target) {\n          const willChangeName = getWillChangeName(key);\n          if (willChangeName) {\n            values.willChange = \"transform\";\n            return;\n          }\n        }\n      });\n    }\n  }\n  return values;\n}\nexport { makeUseVisualState };","map":null,"metadata":{},"sourceType":"module"}